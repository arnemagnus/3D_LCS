\subsection{Choosing new trajectory start points by an algorithm with memory}
\label{sub:choosing_new_trajectory_start_points_by_an_algorithm_with_memory}

Our method of choosing parameter values $\breve{s}$ corresponding to points
along $\mathcal{C}_{i}$ (cf.\ \cref{eq:faithful_initialcondition_interval}),
from which to compute trajectories of the direction field given by
\cref{eq:faithful_local_directionfield} --- with the intention of computing new
mesh points --- rests on the assumption that
\begin{equation}
    \label{eq:faithful_endpoint_separation}
    \Delta(\breve{s}) := \norm{\vct{x}_{\text{end}}(\breve{s})-\vct{x}_{i,j}}, %
    \quad \vct{x}_{\text{end}}\in\mathcal{H}_{i,j}
\end{equation}
is a continuous function of $\breve{s}$. To this end, we keep track of
why each computed trajectory is terminated. In particular, we first note whether
or not each trajectory, corresponding to a start point $\vct{x}(\breve{s})$,
ends up at some point $\vct{x}_{\text{end}}\in\mathcal{H}_{i,j}$.
If this is the case, we also note whether the separation $\Delta(\breve{s})$
(defined in \cref{eq:faithful_endpoint_separation}) corresponding was an
over- or undershoot compared to the desired separation $\Delta_{i}$.

Based on the premises outlined above, we then make use of the intermediate
value theorem; specifically, if we have
\begin{subequations}
    \begin{equation}
        \label{eq:faithful_IVT_part_one}
        \Delta(\breve{s}_{1}) < \Delta_{i},\quad \Delta(\breve{s}_{2}) > \Delta_{i}
    \end{equation}
    for $\breve{s}_{1} < \breve{s}_{2}$, then the intermediate value theorem
    implies that we must have
    \begin{equation}
        \label{eq:faithful_IVT_part_one}
        \Delta(\breve{s}) = \Delta_{i}, \quad \breve{s}_{1} < \breve{s} < \breve{s}_{2},
    \end{equation}
\end{subequations}
under the assumption that $\Delta(\breve{s})$ is a continuous function. In order
to optimize our use of computational resources, we thus endeavor to take large
steps when moving along $\mathcal{C}_{i}$ whenever the computed intersections
with $\mathcal{H}_{i,j}$ are far from fulfilling
$\Delta(\breve{s}) = \Delta_{i}$. However, when a subinterval of
$\mathcal{C}_{i}$ within which the intermediate value theorem suggests that
a trajectory may fulfill our requirements is identified, we decrease the
(quasi-)arclength increment $\delta\breve{s}$ in order to increase our odds of
finding said trajectory. The increment $\delta\breve{s}$ was not allowed
to decrease beyond a pre-set $\delta\breve{s}_{\text{min}}$, nor to increase
beyond a pre-set $\delta\breve{s}_{\text{max}}$. The latter limitation was made
in order to avoid bypassing subsets of $\mathcal{C}_{i}$ from which two
or more trajectories satisfy $\Delta(\breve{s}) = \Delta_{i}$. Overstepping
any region containing an even number of such intersections could render it
undetectable using our intermediate value theorem-based approach, as no change
in trajectory termination status need be detected.

The feedback received by tracking why each trajectory is terminated, allows
us to dynamically select new trajectory start points along $\mathcal{C}_{i}$.
We do so by increasing the (quasi-)arclength increment $\delta\breve{s}$ as long
as there is no change in trajectory termination status, and, conversely,
backtracking and reducing $\delta\breve{s}$ when a status change is detected.
This process is shown schematically in \emph{\textbf{SETT INN REF TIL FIGUR
MED FLOWCHART}}. Note that our algorithm is not perfect; theoretical closed
loops exist (left for the interested reader to find, as an exercise). However,
in our experience, the iterative search process never became stuck beyond
recovery; likely due to the direction field
\cref{eq:faithful_local_directionfield} yielding well-behaved trajectories
(and, possibly, numerical round-off error). As we assume asymptotic behaviour
close to any regions in which $\Delta(\breve{s})$ is not defined (that is,
regions where no trajectories reach the half-plane $\mathcal{H}_{i,j}$, cf.\
\cref{eq:faithful_endpoint_separation}), the adjustment of $\delta\breve{s}$
is treated in the same fashion there.
